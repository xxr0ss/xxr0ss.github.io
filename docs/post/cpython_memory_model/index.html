<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CPython内存模型 | XX の Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="本文源码基于CPython 3.10
Python实现了自己的内存管理，用以加快内存操作和减少内存碎片化。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给malloc()。
// Objects/obmalloc.c #define SMALL_REQUEST_THRESHOLD 512 内存管理模型 Python的内存分配器分成如下层级
Object-specific allocators _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | &#43;3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; | _______________________________ | | [ Python&#39;s object allocator ] | | &#43;2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; | ______________________________________________________________ | [ Python&#39;s raw memory allocator (PyMem_ API) ] | &#43;1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | &lt;------ Virtual memory allocated for the python process -------&gt; | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; | __________________________________ __________________________________ [ ] [ ] -2 | &lt;-- Physical memory: ROM/RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; | 按Python内存模型，一个典型的调用过程如下：">
<meta name="author" content="">
<link rel="canonical" href="https://xxr0ss.github.io/post/cpython_memory_model/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css" integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js" integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93&#43;QdxBJM917LmaT3s9E="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://xxr0ss.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xxr0ss.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xxr0ss.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xxr0ss.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xxr0ss.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CPython内存模型" />
<meta property="og:description" content="本文源码基于CPython 3.10
Python实现了自己的内存管理，用以加快内存操作和减少内存碎片化。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给malloc()。
// Objects/obmalloc.c #define SMALL_REQUEST_THRESHOLD 512 内存管理模型 Python的内存分配器分成如下层级
Object-specific allocators _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | &#43;3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; | _______________________________ | | [ Python&#39;s object allocator ] | | &#43;2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; | ______________________________________________________________ | [ Python&#39;s raw memory allocator (PyMem_ API) ] | &#43;1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | &lt;------ Virtual memory allocated for the python process -------&gt; | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; | __________________________________ __________________________________ [ ] [ ] -2 | &lt;-- Physical memory: ROM/RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; | 按Python内存模型，一个典型的调用过程如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xxr0ss.github.io/post/cpython_memory_model/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-29T02:00:00&#43;08:00" />
<meta property="article:modified_time" content="2021-11-29T02:00:00&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CPython内存模型"/>
<meta name="twitter:description" content="本文源码基于CPython 3.10
Python实现了自己的内存管理，用以加快内存操作和减少内存碎片化。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给malloc()。
// Objects/obmalloc.c #define SMALL_REQUEST_THRESHOLD 512 内存管理模型 Python的内存分配器分成如下层级
Object-specific allocators _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | &#43;3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; | _______________________________ | | [ Python&#39;s object allocator ] | | &#43;2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; | ______________________________________________________________ | [ Python&#39;s raw memory allocator (PyMem_ API) ] | &#43;1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | &lt;------ Virtual memory allocated for the python process -------&gt; | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; | __________________________________ __________________________________ [ ] [ ] -2 | &lt;-- Physical memory: ROM/RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; | 按Python内存模型，一个典型的调用过程如下："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xxr0ss.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CPython内存模型",
      "item": "https://xxr0ss.github.io/post/cpython_memory_model/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CPython内存模型",
  "name": "CPython内存模型",
  "description": "本文源码基于CPython 3.10\nPython实现了自己的内存管理，用以加快内存操作和减少内存碎片化。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给malloc()。\n// Objects/obmalloc.c #define SMALL_REQUEST_THRESHOLD 512 内存管理模型 Python的内存分配器分成如下层级\nObject-specific allocators _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | +3 | \u0026lt;----- Object-specific memory -----\u0026gt; | \u0026lt;-- Non-object memory --\u0026gt; | _______________________________ | | [ Python\u0026#39;s object allocator ] | | +2 | ####### Object memory ####### | \u0026lt;------ Internal buffers ------\u0026gt; | ______________________________________________________________ | [ Python\u0026#39;s raw memory allocator (PyMem_ API) ] | +1 | \u0026lt;----- Python memory (under PyMem manager\u0026#39;s control) ------\u0026gt; | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | \u0026lt;------ Virtual memory allocated for the python process -------\u0026gt; | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | \u0026lt;--- Kernel dynamic storage allocation \u0026amp; management (page-based) ---\u0026gt; | __________________________________ __________________________________ [ ] [ ] -2 | \u0026lt;-- Physical memory: ROM/RAM --\u0026gt; | | \u0026lt;-- Secondary storage (swap) --\u0026gt; | 按Python内存模型，一个典型的调用过程如下：",
  "keywords": [
    
  ],
  "articleBody": "本文源码基于CPython 3.10\nPython实现了自己的内存管理，用以加快内存操作和减少内存碎片化。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给malloc()。\n// Objects/obmalloc.c #define SMALL_REQUEST_THRESHOLD 512 内存管理模型 Python的内存分配器分成如下层级\nObject-specific allocators _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | +3 | \u003c----- Object-specific memory -----\u003e | \u003c-- Non-object memory --\u003e | _______________________________ | | [ Python's object allocator ] | | +2 | ####### Object memory ####### | \u003c------ Internal buffers ------\u003e | ______________________________________________________________ | [ Python's raw memory allocator (PyMem_ API) ] | +1 | \u003c----- Python memory (under PyMem manager's control) ------\u003e | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | \u003c------ Virtual memory allocated for the python process -------\u003e | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | \u003c--- Kernel dynamic storage allocation \u0026 management (page-based) ---\u003e | __________________________________ __________________________________ [ ] [ ] -2 | \u003c-- Physical memory: ROM/RAM --\u003e | | \u003c-- Secondary storage (swap) --\u003e | 按Python内存模型，一个典型的调用过程如下：\nPyDict_New() # 3层 PyObject_GC_New() # 2层 PyObject_Malloc() # 2层 new_arena() # 1层 malloc() # 0层 第0层往下是操作系统和硬件的内存实现，就不在Python的讨论范畴了。\n以下内容的前提是，python使用它自己的small-block内存分配器，当然，大多数情况下还是启用了的。\n// pyconfig.h /* Use Python's own small-block memory-allocator. */ #define WITH_PYMALLOC 1 // 默认是打开的 此时PYOBJ_ALLOC指向_PyObject_*APIs，而不是和PYRAW_ALLOC一样指向_PyMem_*APIs\n// obmalloc.c #define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree} #ifdef WITH_PYMALLOC # define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free} #endif #define PYRAW_ALLOC MALLOC_ALLOC #ifdef WITH_PYMALLOC # define PYOBJ_ALLOC PYMALLOC_ALLOC #else # define PYOBJ_ALLOC MALLOC_ALLOC #endif #define PYMEM_ALLOC PYOBJ_ALLOC 几种内存单位 Python抽象出arena，pool，block这三种内存单位，对应关系如下。在使用本文这种内存管理机制的情况下，每次内存请求的目标是获取到一个足够大小的block。\n通过数组和多条链表进行管理，使得内存分配开销从O(N)到O(1)。\npool通过freeblock和nextoffset字段以数组+单链表形式对block进行管理 arena通过freepools和address字段以数组+单链表形式对pool进行管理 usedpools[]全局变量通过存储多条双向链表维护当前已使用且还能继续分配block的pool unused_arena_objects全局变量单链表管理已创建但未与（_PyObject_Arena.alloc()分配的）实际堆内存关联的arena_object usable_arena全局变量双向链表按拥有空闲pool数量升序维护可用arena arenas全局变量维护所有已创建的arena_object（不一定已经被_PyObject_Arena.alloc()分配了实际堆内存） 以上的总结性描述暂时还不好理解，我们可以在阅读下面内容时，再来回顾。\nblock在pool中的组织方式 block这个词语的指代稍微有些混乱，先做一点解释。\n/* When you say memory, my mind reasons in terms of (pointers to) blocks */ typedef uint8_t block; 代码中的block就是uint8_t，但是代码写起来都是用block*指针，来指向前面所提到内存单元中的，不同类型的pool中，大小不一，但是都对齐到ALIGNMENT宏的整数倍个字节大小的内存块。以下的block一词，都指内存块，而不是单个uint8_t。\npool的结构 每个pool都维护相同大小的block，在较早的python中，block大小为8的倍数\n* For small requests we have the following table: * * Request in bytes Size of allocated block Size class idx * ---------------------------------------------------------------- * 1-8 8 0 * 9-16 16 1 * 17-24 24 2 * 25-32 32 3 * 33-40 40 4 * 41-48 48 5 * 49-56 56 6 * 57-64 64 7 * 65-72 72 8 * ... ... ... * 497-504 504 62 * 505-512 512 63 * * 0, SMALL_REQUEST_THRESHOLD + 1 and up: routed to the underlying * allocator. 但是较新版的源码中，在x86_64机器上是16的倍数了。\n#if SIZEOF_VOID_P \u003e 4 #define ALIGNMENT 16 /* must be 2^N */ #define ALIGNMENT_SHIFT 4 #else #define ALIGNMENT 8 /* must be 2^N */ #define ALIGNMENT_SHIFT 3 #endif 比如ALIGNMENT为16的情况下，size class为0的pool长这样：\n头部储存在pool里，保存一些重要信息。\nobmalloc.c中pool_header的定义\nstruct pool_header { union { block *_padding; uint count; } ref; // pool中已分配block的数量 block *freeblock; // 指向下一个空闲block struct pool_header *nextpool; // 下一个同size class的pool struct pool_header *prevpool; uint arenaindex; // 该pool所属的arena uint szidx; // 当前的pool分配哪一类的空间, 等于usepools中的idx uint nextoffset; // 从未分配过的block偏移 uint maxnextoffset; // nextoffset最大值，超过说明block都分配过，且如果没有block被释放，说明pool已满 }; typedef struct pool_header *poolp; 了解完pool_header结构体，再来看一个pool详细的样子，单个pool大小是4Kb，为大多数系统的页大小，但在新的CPython中有变化，USE_LARGE_POOLS定义下是16Kb。\n我们先关注下面这个pool怎么以数组+单链表形式来维护block\npool三种状态 used：其中部分block被分配了，且至少有一个block没被分配。这也意味着一个pool至少有两个block。因为pool只有在需要内存的时候才被分配，所以used是一个pool的初始状态，而不是empty full: 所有block都被分配了，pool会被从usedpools[]上取下，此时pool的prevpool和nextpool没有实际意义 empty：所有block都可用，pool会被从usedpools[]上取下，放回对应arena_object的单链表freepools里面，此时pool的prevpool没有实际意义 在pool中申请空间有几种情况，但是有一个原则很简单就是每次去找freeblock指向的内存块，再根据情况更新一些数据。\n下面的内容涉及到usedpools[]对pool的管理，但我们主要关注pool怎么管理block\n在未释放过block的pool中申请新的空间 每次freeblock都指向一个内容为NULL的block，表明目前 pool 中没有其他之前被申请过但是当前已经被释放了的 block 存在，新申请空间的话，需要从 pool 尾部寻找之前没有用到过的新的空间。\n这时候的管理更像是数组形式，nextoffset和 maxnextoffset在这种情况下会被用来查看 pool 尾部是否还有剩余的未使用过的空间。\n然后就是更新ref.count，nextoffset，freeblock了。每次freeblock更新为nextoffset指向的地址，所以这里的图中，freeblock指向倒数第3个块，而pool+nextoffset在倒数第2个block\n这一部分的代码\nstatic void pymalloc_pool_extend(poolp pool, uint size) { // freeblock为NULL时，扩展pool尾部 if (UNLIKELY(pool-\u003enextoffset \u003c= pool-\u003emaxnextoffset)) { /* There is room for another block. */ pool-\u003efreeblock = (block*)pool + pool-\u003enextoffset; pool-\u003enextoffset += INDEX2SIZE(size); *(block **)(pool-\u003efreeblock) = NULL; return; } /* Pool is full, unlink from used pools. */ poolp next; next = pool-\u003enextpool; pool = pool-\u003eprevpool; next-\u003eprevpool = pool; pool-\u003enextpool = next; } static inline void* pymalloc_alloc(void *ctx, size_t nbytes) { // ... if (UNLIKELY(nbytes == 0)) { return NULL; } if (UNLIKELY(nbytes \u003e SMALL_REQUEST_THRESHOLD)) { return NULL; } uint size = (uint)(nbytes - 1) \u003e\u003e ALIGNMENT_SHIFT; poolp pool = usedpools[size + size]; block *bp; if (LIKELY(pool != pool-\u003enextpool)) { /* * There is a used pool for this size class. * Pick up the head block of its free list. */ ++pool-\u003eref.count; bp = pool-\u003efreeblock; assert(bp != NULL); // 这里的freeblock赋值还是比较巧妙的，可以思考下 if (UNLIKELY((pool-\u003efreeblock = *(block **)bp) == NULL)) { // Reached the end of the free list, try to extend it. pymalloc_pool_extend(pool, size); } } // ... } 申请完毕后\n再申请一个\n此时nextoffset大于maxnextoffset了。\n再申请\nnextoffset 的值比 maxnextoffset 的大, 表示尾部已经没有多余的新的未使用过的空间可以使用了, 并且目前情况下当前的pool是满的了, 所以freeblock变成了一个空指针\n因为pool已经满了, 我们需要把pool从usedpools全局变量管理的双向链表中移除。本例中这个pool的block都是8字节，所以这个pool本来位于usedpools[0]和usedpools[1]维护的一条双链表中。\n在pool中释放block的核心代码如下：\nblock *lastfree = pool-\u003efreeblock; *(block **)p = lastfree; pool-\u003efreeblock = (block *)p; pool-\u003eref.count--; 其实就是把要释放的内存，插入到freeblock指向的单链表中的头部。链表每个节点都是没有用到的block，正好用来指向下一个空闲block的地址。\n在满的 pool 中进行释放 释放如图位置的block。\nstep1，把内存块里第一个block的值设置为和 freeblock相同的值，图中因为是满的，所以设置为了NULL\nstep2, 让freeblock指向当前正在释放的block\n减小ref.count的值\nstep3，检查pool释放内存之前是否是满的(通过检查当前正在释放的block是否空指针即可确定)，如果是, 把pool重新链接到usedpools中并返回, 如果不是则跳转到 step4\nstep4\n检查当前arena中的所有的pools是否都为空的, 如果是的话, 释放整个arena\n如果这是arena中唯一的有空余空间的pool，把arena加回到 usable_arenas 列表中\n给usable_arenas进行排序, 确保更多空的pool的arena排在更后面\n释放block的pymalloc_free(void *ctx, void *p)源码\n// obmalloc.c /* Free a memory block allocated by pymalloc_alloc(). Return 1 if it was freed. Return 0 if the block was not allocated by pymalloc_alloc(). */ static inline int pymalloc_free(void *ctx, void *p) { assert(p != NULL); #ifdef WITH_VALGRIND if (UNLIKELY(running_on_valgrind \u003e 0)) { return 0; } #endif poolp pool = POOL_ADDR(p); if (UNLIKELY(!address_in_range(p, pool))) { return 0; } /* We allocated this address. */ /* Link p to the start of the pool's freeblock list. Since // 用过但释放了的block，在此收入freeblock单链表进行管理 * the pool had at least the p block outstanding, the pool * wasn't empty (so it's already in a usedpools[] list, or * was full and is in no list -- it's not in the freeblocks * list in any case). */ assert(pool-\u003eref.count \u003e 0); /* else it was empty */ block *lastfree = pool-\u003efreeblock; *(block **)p = lastfree; pool-\u003efreeblock = (block *)p; pool-\u003eref.count--; if (UNLIKELY(lastfree == NULL)) { /* Pool was full, so doesn't currently live in any list: * link it to the front of the appropriate usedpools[] list. * This mimics LRU pool usage for new allocations and * targets optimal filling when several pools contain * blocks of the same size class. */ insert_to_usedpool(pool); return 1; } /* freeblock wasn't NULL, so the pool wasn't full, * and the pool is in a usedpools[] list. */ if (LIKELY(pool-\u003eref.count != 0)) { /* pool isn't empty: leave it in usedpools */ return 1; } /* Pool is now empty: unlink from usedpools, and * link to the front of freepools. This ensures that * previously freed pools will be allocated later * (being not referenced, they are perhaps paged out). */ insert_to_freepool(pool); return 1; } POOL_ADDR(p)的设计： 因为pool保证对齐到4KiB（定义了USE_LARGE_POOL时对齐到16KiB）\n#ifdef USE_LARGE_POOLS #define POOL_BITS 14 /* 16 KiB */ #else #define POOL_BITS 12 /* 4 KiB */ #endif #define POOL_SIZE (1 \u003c\u003c POOL_BITS) #define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) \u0026 ~(uintptr_t)((a) - 1))) #define POOL_ADDR(P) ((poolp)_Py_ALIGN_DOWN((P), POOL_SIZE)) 简便起见，假如POOL_SIZE是0b00001000，一个block的地址是0b00011010，那么这里的计算方式就是\n0b00011010 \u0026 ~(0b00001000 - 1) = 0b00011010 \u0026 ~0b00000111 = 0b00011010 \u0026 0b11111000 = 0b00011000 在有空余空间的 pool 中进行释放 其实步骤和上面一样，比如释放最后一个内存块，位于0x10ae3dff8\nStep1 设置当前释放的内存块的值\nStep2\n更新freeblock指针\n减小ref.count\nStep3 显然pool之前不是满的，直接跳到Step4\nStep4 返回\n再来释放倒数第二个，也是同理\nStep1\nStep2\nStep3 pool之前不满，跳到step4\nStep4返回\n在释放过block的pool中申请新的空间 和在未释放过block的pool中申请新的空间是一样的思路。从代码上来看\n// pymalloc_alloc in obmalloc.c ++pool-\u003eref.count; bp = pool-\u003efreeblock; assert(bp != NULL); if (UNLIKELY((pool-\u003efreeblock = *(block **)bp) == NULL)) { // Reached the end of the free list, try to extend it. pymalloc_pool_extend(pool, size); } 和之前的区别在于这次从freeblock获取到的不是NULL了，就不用进入pymalloc_pool_extend()\npool在arena和usedpools中的组织方式 内存请求的过程 一个arena中存储了许多大小相同的pool，不同arena的pool大小不一定相同。 arenas[]保存了所有arena_object usedpools[]是一个全局数组，其中的元素是个双向链表，两个元素为一组，将相同大小的pool串起来。一个size没有分配pool时，usedpools[size+size]里面的节点指向的pool的prevpool和nextpool都指向自己。 先来看看usedpools[]，内存请求到达pymalloc_alloc时，小于等于SMALL_REQUEST_THRESHOLD的请求，就是在usedpools里来找合适大小的pool。寻找的方式是\n计算请求内存大小所属size class：uint size = (uint)(nbytes - 1) \u003e\u003e ALIGNMENT_SHIFT 在usedpools[size + size]上寻找pool 如果没有合适大小的pool，就会从arenas里请求新的pool，添加到对应位置的双向链表上，从这个新pool中申请block。\nusedpools的初始定义\n// usedpools初始化 #define PTA(x) ((poolp )((uint8_t *)\u0026(usedpools[2*(x)]) - 2*sizeof(block *))) #define PT(x) PTA(x), PTA(x) static poolp usedpools[2 * ((NB_SMALL_SIZE_CLASSES + 7) / 8) * 8] = { PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7) #if NB_SMALL_SIZE_CLASSES \u003e 8 , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15) #if NB_SMALL_SIZE_CLASSES \u003e 16 , PT(16), PT(17), PT(18), PT(19), PT(20), PT(21), PT(22), PT(23) #if NB_SMALL_SIZE_CLASSES \u003e 24 , PT(24), PT(25), PT(26), PT(27), PT(28), PT(29), PT(30), PT(31) #if NB_SMALL_SIZE_CLASSES \u003e 32 , PT(32), PT(33), PT(34), PT(35), PT(36), PT(37), PT(38), PT(39) #if NB_SMALL_SIZE_CLASSES \u003e 40 , PT(40), PT(41), PT(42), PT(43), PT(44), PT(45), PT(46), PT(47) #if NB_SMALL_SIZE_CLASSES \u003e 48 , PT(48), PT(49), PT(50), PT(51), PT(52), PT(53), PT(54), PT(55) #if NB_SMALL_SIZE_CLASSES \u003e 56 , PT(56), PT(57), PT(58), PT(59), PT(60), PT(61), PT(62), PT(63) #if NB_SMALL_SIZE_CLASSES \u003e 64 #error \"NB_SMALL_SIZE_CLASSES should be less than 64\" #endif /* NB_SMALL_SIZE_CLASSES \u003e 64 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 56 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 48 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 40 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 32 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 24 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 16 */ #endif /* NB_SMALL_SIZE_CLASSES \u003e 8 */ }; 上面这个代码有点巧妙，我们看下usedpools@0x00007FFED35FF410刚初始化后里面长啥样\n回顾一下pool_header定义就知道是怎么回事了。\n比如0+0位置上维护的双链表，\u0026usedpools[0+0]在0x00007FFED35FF410，而usedpools[0+0]为0x00007FFED35FF400，(pool_header*)0x00007FFED35FF400-\u003enextpool 跨过两个指针大小的内存，刚好就指向\u0026usedpools[0+0]了，也就是usedpools[size+size]-\u003enextpool==\u0026usedpools[size+size]\n总之初始化的值使得正好所有的usedpools[size+size]的pool的prevpool和nextpool字段都指向自己了。\n现在假设我们一开始请求一个10字节的内存块。\n初始时没有能用的arena和pool，于是在new_arena()中：第一次创建的是16个新的arena，分配了16个arena_object结构体的空间，保存到全局变量arenas[]。但并没有立即分配16个ARENA_SIZE的空间作为arena。然后初始化unused_arena_objects指向的arena_object，此时也就是arenas[0]。\n第一个可用的arena的第一个空闲pool被插入used_pools里。sentinel就是哨兵的意思，idx1指向的sentinel其实存的是used_pools[0]的地址（没理解的话查看上面内容）。\n然后按照前面讲到的在未释放过block的pool中申请新的空间获得请求所需要的内存块。\narena中对pool的管理 arena管理pool的方式和pool管理block的方式非常相似。也是数组+单链表。\narena_object结构体：\n源码如下，注释说得比较清楚\n/* Record keeping for arenas. */ struct arena_object { /* The address of the arena, as returned by malloc. Note that 0 * will never be returned by a successful malloc, and is used * here to mark an arena_object that doesn't correspond to an * allocated arena. */ uintptr_t address; /* Pool-aligned pointer to the next pool to be carved off. */ block* pool_address; /* The number of available pools in the arena: free pools + never- * allocated pools. */ uint nfreepools; /* The total number of pools in the arena, whether or not available. */ uint ntotalpools; /* Singly-linked list of available pools. */ struct pool_header* freepools; /* Whenever this arena_object is not associated with an allocated * arena, the nextarena member is used to link all unassociated * arena_objects in the singly-linked `unused_arena_objects` list. * The prevarena member is unused in this case. * * When this arena_object is associated with an allocated arena * with at least one available pool, both members are used in the * doubly-linked `usable_arenas` list, which is maintained in * increasing order of `nfreepools` values. * * Else this arena_object is associated with an allocated arena * all of whose pools are in use. `nextarena` and `prevarena` * are both meaningless in this case. */ struct arena_object* nextarena; struct arena_object* prevarena; }; 当然，我这可以再翻译一下和做点解释\naddress\n用来保存分配给arena地址。\npool_address\npool的地址，指向下一个要取出的pool的地址\n因为malloc()返回给arena的地址不一定对齐到POOL_SIZE，所以如果真的没有对齐，那么arena会舍弃前后加起来共POOL_SIZE大小的空间（图中POOL_SIZE为4K），保证最开始时，pool_address指向已经对齐好的pool，随时可以分配。\narena的对齐实现：\n在未释放过pool的arena中申请新的空间 按顺序，前面的所有pool都是used，pool_address负责指向空闲内存\n申请一个新的pool，从pool_address上取\nnfreepools减小，pool_address更新为下一个空余的pool\n再申请一个，满了。\n在arena中释放空间 pool变为empty时，pool从usedpools中移除，插入到与之对应的arena中，freepools所管理的单链表中。\n比如我们释放pool3\npool3-\u003enextpool设置为arena-\u003efreepools相同值。因为是满了之后第一个释放的，所以这个时候是0\nfreepools更新为pool3的地址，nfreepools增加\n比如再释放一个pool63\n在释放过pool的arena中申请新的空间 在arena中申请新的空间，先判断freepools是不是NULL。这里的情况下，nfreepools大于0，freepools不为空，从这个单链表中取pool。\n更新freepools指针，和nfreepools\narena的管理 arena由arena_object结构体数组arenas[]和链表unused_arena_objects和usable_arenas进行管理。\n单链表**unused_arena_objects**\n维护arenas中所有pool都没被使用或都被释放了的arena_object，凡是放入这个链表的arena_object，其arena占用的pool都会被释放，但arena_object结构体本身不会被释放。\n在 Python 2.5 之前, arena申请过的空间是从来不会被释放的, 这个策略是在 Python 2.5 之后引入的。\n双向链表**usable_arenas** 维护有空闲pool的arena的arena_object\n第一次内存请求前没有分配arena_object，usable_arenas == NULL，第一次分配时，分配16个arena_object存入arenas[]，之后每次扩容arenas，总共分配的arena_object数量翻倍。\n由于是第一次分配，所以先构建unused_arena_objects单链表，留在这个链表中的arena_object一定是没分配实际内存的，也就是address字段是0\n（白色为不关联实际内存，绿色表示有可用pool，红色表示所有pool已满）\nnew_arena()内从unused_arena_objects处获取arena_object并为之真正分配ARENA_SIZE的内存，做好初始化：对齐arena中的pool到POOL_SIZE，设置一些字段。\nusable_arenas是个双向链表（下图没体现出来），维护包含空闲pool的arena，管理的arena_object按其nfreepools升序排列，获取pool时，优先从重度使用的arena中分配，这样可以让比较空的arena有更多释放内存的可能性。\n16个arena都用完了的时候，arena_objects数量翻倍，然后做前面同样的初始化。\n扩容用的realloc，不用管指针了？是的。因为既然前面的arena_objects对应的arena都满了，usable_arenas和unused_arena_objects就都为NULL了，自然也没有nextarena，prevarena指针指向原来的内存，realloc后，构建新的unused_arena_objects单链表\n返回新的arena给usable_arenas\nnew_arena()源码\n// obmalloc.c /* Allocate a new arena. If we run out of memory, return NULL. Else * allocate a new arena, and return the address of an arena_object * describing the new arena. It's expected that the caller will set * `usable_arenas` to the return value. */ static struct arena_object* new_arena(void) { struct arena_object* arenaobj; uint excess; /* number of bytes above pool alignment */ void *address; static int debug_stats = -1; if (debug_stats == -1) { const char *opt = Py_GETENV(\"PYTHONMALLOCSTATS\"); debug_stats = (opt != NULL \u0026\u0026 *opt != '\\0'); } if (debug_stats) _PyObject_DebugMallocStats(stderr); if (unused_arena_objects == NULL) { uint i; uint numarenas; size_t nbytes; /* Double the number of arena objects on each allocation. * Note that it's possible for `numarenas` to overflow. */ numarenas = maxarenas ? maxarenas \u003c\u003c 1 : INITIAL_ARENA_OBJECTS; // 将最大arenas数量翻倍 if (numarenas \u003c= maxarenas) return NULL; /* overflow */ #if SIZEOF_SIZE_T \u003c= SIZEOF_INT if (numarenas \u003e SIZE_MAX / sizeof(*arenas)) return NULL; /* overflow */ #endif nbytes = numarenas * sizeof(*arenas); arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes); // realloc内存 if (arenaobj == NULL) return NULL; arenas = arenaobj; /* We might need to fix pointers that were copied. However, // Realloc后的指针无需处理 * new_arena only gets called when all the pages in the // 因为前面的arena满了，才需要realloc， * previous arenas are full. Thus, there are *no* pointers // 既然满了，就没有指针(unused_arena_objects 和 usable_arenas链表中的指针) * into the old array. Thus, we don't have to worry about // 指向原来的arenas数组里。 * invalid pointers. Just to be sure, some asserts: */ assert(usable_arenas == NULL); assert(unused_arena_objects == NULL); /* Put the new arenas on the unused_arena_objects list. */ for (i = maxarenas; i \u003c numarenas; ++i) { arenas[i].address = 0; /* mark as unassociated */ arenas[i].nextarena = i \u003c numarenas - 1 ? \u0026arenas[i+1] : NULL; } /* Update globals. */ unused_arena_objects = \u0026arenas[maxarenas]; // unused_arena_objects指向arenas新扩容出来的部分头部 maxarenas = numarenas; } /* Take the next available arena object off the head of the list. */ assert(unused_arena_objects != NULL); arenaobj = unused_arena_objects; unused_arena_objects = arenaobj-\u003enextarena; assert(arenaobj-\u003eaddress == 0); address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE); #if WITH_PYMALLOC_RADIX_TREE if (address != NULL) { if (!arena_map_mark_used((uintptr_t)address, 1)) { /* marking arena in radix tree failed, abort */ _PyObject_Arena.free(_PyObject_Arena.ctx, address, ARENA_SIZE); address = NULL; } } #endif if (address == NULL) { /* The allocation failed: return NULL after putting the * arenaobj back. */ arenaobj-\u003enextarena = unused_arena_objects; unused_arena_objects = arenaobj; return NULL; } arenaobj-\u003eaddress = (uintptr_t)address; ++narenas_currently_allocated; ++ntimes_arena_allocated; if (narenas_currently_allocated \u003e narenas_highwater) narenas_highwater = narenas_currently_allocated; arenaobj-\u003efreepools = NULL; /* pool_address \u003c- first pool-aligned address in the arena nfreepools \u003c- number of whole pools that fit after alignment */ arenaobj-\u003epool_address = (block*)arenaobj-\u003eaddress; arenaobj-\u003enfreepools = MAX_POOLS_IN_ARENA; excess = (uint)(arenaobj-\u003eaddress \u0026 POOL_SIZE_MASK); // 当前arena地址没对齐到pool大小 if (excess != 0) { --arenaobj-\u003enfreepools; // 为了对齐pool，可用pool会减少一个 arenaobj-\u003epool_address += POOL_SIZE - excess; // 进行对齐操作 } arenaobj-\u003entotalpools = arenaobj-\u003enfreepools; return arenaobj; } 一些API obmalloc中的调用链 _PyObject_Malloc和_PyObject_Calloc调用pymalloc_alloc，申请的内存大于SMALL_REQUEST_THRESHOLD的内存时，pymalloc_alloc返回NULL，于是前者又分别会调用PyMem_RawMalloc和PyMem_RawCalloc\n参考源码_PyObject_Malloc和_PyObject_Calloc的实现\nsmall request的调用链\nPyObject_Malloc(size_t size) -\u003e _PyObject.malloc == (PYOBJ_ALLOC == PYMALLOC_ALLOC).malloc == _PyObject_Malloc _PyObject_Malloc(void *ctx, size_t nbytes) -\u003e pymalloc_alloc(void *ctx, size_t nbytes) get memory from pool bigger request的调用链\nPyObject_Malloc(size_t size) -\u003e _PyObject.malloc == (PYOBJ_ALLOC == PYMALLOC_ALLOC).malloc == _PyObject_Malloc _PyObject_Malloc(void *ctx, size_t nbytes) get NULL from pymalloc_alloc -\u003e PyMem_RawMalloc(size_t size) -\u003e malloc(size_t size) of CRT PyMem_系列\nobmalloc.c中：\n#define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree} #ifdef WITH_PYMALLOC # define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free} #endif #define PYRAW_ALLOC MALLOC_ALLOC #ifdef WITH_PYMALLOC # define PYOBJ_ALLOC PYMALLOC_ALLOC #else # define PYOBJ_ALLOC MALLOC_ALLOC #endif #define PYMEM_ALLOC PYOBJ_ALLOC 默认是定义了WITH_PYMALLOC的，也就是说默认选用_PyObject_*函数族而不是_PyMem_Raw*\nWITH_PYMALLOC\nPYMEM_ALLOC→PYOBJ_ALLOC→PYMALLOC_ALLOC→_PyObject_*函数族\n没有WITH_PYMALLOC\nPYMEM_ALLOC→PYOBJ_ALLOC→MALLOC_ALLOC→_PyMem_Raw*函数族\nTODO bpo-37029: keep usable_arenas in sorted order without searching (#13… · python/cpython@1c263e3 (github.com) ",
  "wordCount" : "2117",
  "inLanguage": "en",
  "datePublished": "2021-11-29T02:00:00+08:00",
  "dateModified": "2021-11-29T02:00:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xxr0ss.github.io/post/cpython_memory_model/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "XX の Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xxr0ss.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xxr0ss.github.io/" accesskey="h" title="XX の Blog (Alt + H)">XX の Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      CPython内存模型
    </h1>
    <div class="post-meta"><span title='2021-11-29 02:00:00 +0800 CST'>November 29, 2021</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9e%8b" aria-label="内存管理模型">内存管理模型</a><ul>
                            
                    <li>
                        <a href="#%e5%87%a0%e7%a7%8d%e5%86%85%e5%ad%98%e5%8d%95%e4%bd%8d" aria-label="几种内存单位">几种内存单位</a></li>
                    <li>
                        <a href="#block%e5%9c%a8pool%e4%b8%ad%e7%9a%84%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f" aria-label="block在pool中的组织方式">block在pool中的组织方式</a><ul>
                            
                    <li>
                        <a href="#pool%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="pool的结构">pool的结构</a></li>
                    <li>
                        <a href="#pool%e4%b8%89%e7%a7%8d%e7%8a%b6%e6%80%81" aria-label="pool三种状态">pool三种状态</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e6%9c%aa%e9%87%8a%e6%94%be%e8%bf%87block%e7%9a%84pool%e4%b8%ad%e7%94%b3%e8%af%b7%e6%96%b0%e7%9a%84%e7%a9%ba%e9%97%b4" aria-label="在未释放过block的pool中申请新的空间">在未释放过block的pool中申请新的空间</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e6%bb%a1%e7%9a%84-pool-%e4%b8%ad%e8%bf%9b%e8%a1%8c%e9%87%8a%e6%94%be" aria-label="在满的 pool 中进行释放">在满的 pool 中进行释放</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e6%9c%89%e7%a9%ba%e4%bd%99%e7%a9%ba%e9%97%b4%e7%9a%84-pool-%e4%b8%ad%e8%bf%9b%e8%a1%8c%e9%87%8a%e6%94%be" aria-label="在有空余空间的 pool 中进行释放">在有空余空间的 pool 中进行释放</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e9%87%8a%e6%94%be%e8%bf%87block%e7%9a%84pool%e4%b8%ad%e7%94%b3%e8%af%b7%e6%96%b0%e7%9a%84%e7%a9%ba%e9%97%b4" aria-label="在释放过block的pool中申请新的空间">在释放过block的pool中申请新的空间</a></li></ul>
                    </li>
                    <li>
                        <a href="#pool%e5%9c%a8arena%e5%92%8cusedpools%e4%b8%ad%e7%9a%84%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f" aria-label="pool在arena和usedpools中的组织方式">pool在arena和usedpools中的组织方式</a><ul>
                            
                    <li>
                        <a href="#%e5%86%85%e5%ad%98%e8%af%b7%e6%b1%82%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="内存请求的过程">内存请求的过程</a></li>
                    <li>
                        <a href="#arena%e4%b8%ad%e5%af%b9pool%e7%9a%84%e7%ae%a1%e7%90%86" aria-label="arena中对pool的管理">arena中对pool的管理</a><ul>
                            
                    <li>
                        <a href="#%e5%9c%a8%e6%9c%aa%e9%87%8a%e6%94%be%e8%bf%87pool%e7%9a%84arena%e4%b8%ad%e7%94%b3%e8%af%b7%e6%96%b0%e7%9a%84%e7%a9%ba%e9%97%b4" aria-label="在未释放过pool的arena中申请新的空间">在未释放过pool的arena中申请新的空间</a></li>
                    <li>
                        <a href="#%e5%9c%a8arena%e4%b8%ad%e9%87%8a%e6%94%be%e7%a9%ba%e9%97%b4" aria-label="在arena中释放空间">在arena中释放空间</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e9%87%8a%e6%94%be%e8%bf%87pool%e7%9a%84arena%e4%b8%ad%e7%94%b3%e8%af%b7%e6%96%b0%e7%9a%84%e7%a9%ba%e9%97%b4" aria-label="在释放过pool的arena中申请新的空间">在释放过pool的arena中申请新的空间</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#arena%e7%9a%84%e7%ae%a1%e7%90%86" aria-label="arena的管理">arena的管理</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%b8%80%e4%ba%9bapi" aria-label="一些API">一些API</a><ul>
                            
                    <li>
                        <a href="#obmalloc%e4%b8%ad%e7%9a%84%e8%b0%83%e7%94%a8%e9%93%be" aria-label="obmalloc中的调用链">obmalloc中的调用链</a></li></ul>
                    </li>
                    <li>
                        <a href="#todo" aria-label="TODO">TODO</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>本文源码基于CPython 3.10</p>
<p>Python实现了自己的内存管理，用以<strong>加快内存操作</strong>和<strong>减少内存碎片化</strong>。Python定义了一个阈值，小于等于这个阈值的小内存请求，由Python实现的这套内存管理来分配，大于则直接交给<code>malloc()</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Objects/obmalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define SMALL_REQUEST_THRESHOLD 512
</span></span></span></code></pre></div><h1 id="内存管理模型">内存管理模型<a hidden class="anchor" aria-hidden="true" href="#内存管理模型">#</a></h1>
<p>Python的内存分配器分成如下层级</p>
<pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">    Object-specific allocators
    _____   ______   ______       ________
   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |
+3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; |
    _______________________________       |                           |
   [   Python&#39;s object allocator   ]      |                           |
+2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; |
    ______________________________________________________________    |
   [          Python&#39;s raw memory allocator (PyMem_ API)          ]   |
+1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; |   |
    __________________________________________________________________
   [    Underlying general-purpose allocator (ex: C library malloc)   ]
 0 | &lt;------ Virtual memory allocated for the python process -------&gt; |

   =========================================================================
    _______________________________________________________________________
   [                OS-specific Virtual Memory Manager (VMM)               ]
-1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; |
    __________________________________   __________________________________
   [                                  ] [                                  ]
-2 | &lt;-- Physical memory: ROM/RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; |
</code></pre><p>按Python内存模型，一个典型的调用过程如下：</p>
<pre tabindex="0"><code class="language-纯文本" data-lang="纯文本">PyDict_New()          # 3层
  PyObject_GC_New()   # 2层
    PyObject_Malloc() # 2层
      new_arena()     # 1层
      malloc()        # 0层
</code></pre><p>第0层往下是操作系统和硬件的内存实现，就不在Python的讨论范畴了。</p>
<p>以下内容的前提是，python使用它自己的small-block内存分配器，当然，大多数情况下还是启用了的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// pyconfig.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/* Use Python&#39;s own small-block memory-allocator. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define WITH_PYMALLOC 1    </span><span style="color:#75715e">// 默认是打开的
</span></span></span></code></pre></div><p>此时<code>PYOBJ_ALLOC</code>指向<code>_PyObject_*</code>APIs，而不是和<code>PYRAW_ALLOC</code>一样指向<code>_PyMem_*</code>APIs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// obmalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef WITH_PYMALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PYRAW_ALLOC MALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef WITH_PYMALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYOBJ_ALLOC PYMALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYOBJ_ALLOC MALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PYMEM_ALLOC PYOBJ_ALLOC
</span></span></span></code></pre></div><h2 id="几种内存单位">几种内存单位<a hidden class="anchor" aria-hidden="true" href="#几种内存单位">#</a></h2>
<p>Python抽象出<strong>arena</strong>，<strong>pool</strong>，<strong>block</strong>这三种内存单位，对应关系如下。在使用本文这种内存管理机制的情况下，每次内存请求的目标是获取到一个足够大小的block。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image.png" alt=""  />
</p>
<p>通过数组和多条链表进行管理，使得内存分配开销从O(N)到O(1)。</p>
<ul>
<li><strong>pool</strong>通过freeblock和nextoffset字段以数组+单链表形式对<strong>block</strong>进行管理</li>
<li><strong>arena</strong>通过freepools和address字段以数组+单链表形式对<strong>pool</strong>进行管理</li>
<li><code>usedpools[]</code>全局变量通过存储多条双向链表维护当前已使用且还能继续分配<strong>block</strong>的<strong>pool</strong></li>
<li><code>unused_arena_objects</code>全局变量单链表管理已创建但未与（<code>_PyObject_Arena.alloc()</code>分配的）实际堆内存关联的<code>arena_object</code></li>
<li><code>usable_arena</code>全局变量双向链表按拥有空闲<strong>pool</strong>数量升序维护可用<strong>arena</strong></li>
<li><code>arenas</code>全局变量维护所有已创建的<code>arena_object</code>（不一定已经被<code>_PyObject_Arena.alloc()</code>分配了实际堆内存）</li>
</ul>
<p>以上的总结性描述暂时还不好理解，我们可以在阅读下面内容时，再来回顾。</p>
<h2 id="block在pool中的组织方式">block在pool中的组织方式<a hidden class="anchor" aria-hidden="true" href="#block在pool中的组织方式">#</a></h2>
<p>block这个词语的指代稍微有些混乱，先做一点解释。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* When you say memory, my mind reasons in terms of (pointers to) blocks */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">uint8_t</span> block;
</span></span></code></pre></div><p>代码中的block就是<code>uint8_t</code>，但是代码写起来都是用<code>block*</code>指针，来指向前面所提到内存单元中的，不同类型的pool中，大小不一，但是都对齐到<code>ALIGNMENT</code>宏的整数倍个字节大小的内存块。以下的block一词，都指内存块，而不是单个<code>uint8_t</code>。</p>
<h3 id="pool的结构">pool的结构<a hidden class="anchor" aria-hidden="true" href="#pool的结构">#</a></h3>
<p>每个pool都维护相同大小的block，在较早的python中，block大小为8的倍数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#f92672">*</span> For small requests we have the following table:
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Request in bytes     Size of allocated block      Size class idx
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> <span style="color:#f92672">----------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>        <span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>                     <span style="color:#ae81ff">8</span>                       <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>        <span style="color:#ae81ff">9</span><span style="color:#f92672">-</span><span style="color:#ae81ff">16</span>                   <span style="color:#ae81ff">16</span>                       <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">17</span><span style="color:#f92672">-</span><span style="color:#ae81ff">24</span>                   <span style="color:#ae81ff">24</span>                       <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">25</span><span style="color:#f92672">-</span><span style="color:#ae81ff">32</span>                   <span style="color:#ae81ff">32</span>                       <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">33</span><span style="color:#f92672">-</span><span style="color:#ae81ff">40</span>                   <span style="color:#ae81ff">40</span>                       <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">41</span><span style="color:#f92672">-</span><span style="color:#ae81ff">48</span>                   <span style="color:#ae81ff">48</span>                       <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">49</span><span style="color:#f92672">-</span><span style="color:#ae81ff">56</span>                   <span style="color:#ae81ff">56</span>                       <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">57</span><span style="color:#f92672">-</span><span style="color:#ae81ff">64</span>                   <span style="color:#ae81ff">64</span>                       <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>       <span style="color:#ae81ff">65</span><span style="color:#f92672">-</span><span style="color:#ae81ff">72</span>                   <span style="color:#ae81ff">72</span>                       <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>        ...                   ...                     ...
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>      <span style="color:#ae81ff">497</span><span style="color:#f92672">-</span><span style="color:#ae81ff">504</span>                 <span style="color:#ae81ff">504</span>                      <span style="color:#ae81ff">62</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>      <span style="color:#ae81ff">505</span><span style="color:#f92672">-</span><span style="color:#ae81ff">512</span>                 <span style="color:#ae81ff">512</span>                      <span style="color:#ae81ff">63</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>      <span style="color:#ae81ff">0</span>, SMALL_REQUEST_THRESHOLD <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> and up: routed to the underlying
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>      allocator.
</span></span></code></pre></div><p>但是较新版的源码中，在x86_64机器上是16的倍数了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#if SIZEOF_VOID_P &gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ALIGNMENT              16               </span><span style="color:#75715e">/* must be 2^N */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ALIGNMENT_SHIFT         4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ALIGNMENT               8               </span><span style="color:#75715e">/* must be 2^N */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ALIGNMENT_SHIFT         3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>比如<code>ALIGNMENT</code>为16的情况下，size class为0的pool长这样：</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_1.png" alt=""  />
</p>
<p>头部储存在pool里，保存一些重要信息。</p>
<ul>
<li>
<p>obmalloc.c中pool_header的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> pool_header {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> { block <span style="color:#f92672">*</span>_padding;
</span></span><span style="display:flex;"><span>            uint count; } ref;          <span style="color:#75715e">// pool中已分配block的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    block <span style="color:#f92672">*</span>freeblock;                   <span style="color:#75715e">// 指向下一个空闲block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> pool_header <span style="color:#f92672">*</span>nextpool;       <span style="color:#75715e">// 下一个同size class的pool
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> pool_header <span style="color:#f92672">*</span>prevpool;       
</span></span><span style="display:flex;"><span>    uint arenaindex;                    <span style="color:#75715e">// 该pool所属的arena
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint szidx;                         <span style="color:#75715e">// 当前的pool分配哪一类的空间, 等于usepools中的idx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint nextoffset;                    <span style="color:#75715e">// 从未分配过的block偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint maxnextoffset;                 <span style="color:#75715e">// nextoffset最大值，超过说明block都分配过，且如果没有block被释放，说明pool已满
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> pool_header <span style="color:#f92672">*</span>poolp;
</span></span></code></pre></div></li>
</ul>
<p>了解完pool_header结构体，再来看一个pool详细的样子，单个pool大小是4Kb，为大多数系统的页大小，但<strong>在新的CPython中有变化，</strong><code>USE_LARGE_POOLS</code><strong>定义下是16Kb</strong>。</p>
<p>我们先关注下面这个pool怎么以数组+单链表形式来维护block</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_2.png" alt=""  />
</p>
<h3 id="pool三种状态">pool三种状态<a hidden class="anchor" aria-hidden="true" href="#pool三种状态">#</a></h3>
<ul>
<li><strong>used</strong>：其中部分block被分配了，且至少有一个block没被分配。这也意味着一个pool至少有两个block。因为pool只有在需要内存的时候才被分配，所以<code>used</code>是一个pool的初始状态，而不是<code>empty</code></li>
<li><strong>full</strong>: 所有block都被分配了，pool会被从<code>usedpools[]</code>上取下，此时pool的<code>prevpool</code>和<code>nextpool</code>没有实际意义</li>
<li><strong>empty</strong>：所有block都可用，pool会被从<code>usedpools[]</code>上取下，放回对应arena_object的单链表<code>freepools</code>里面，此时pool的prevpool没有实际意义</li>
</ul>
<p>在pool中申请空间有几种情况，但是有一个<strong>原则</strong>很简单就是<strong>每次去找</strong><code>freeblock</code><strong>指向的内存块</strong>，再根据情况更新一些数据。</p>
<p>下面的内容涉及到<code>usedpools[]</code>对pool的管理，但我们主要关注pool怎么管理block</p>
<h3 id="在未释放过block的pool中申请新的空间">在未释放过block的pool中申请新的空间<a hidden class="anchor" aria-hidden="true" href="#在未释放过block的pool中申请新的空间">#</a></h3>
<p><img loading="lazy" src="/cpython_memory_model/image/image_3.png" alt=""  />
</p>
<p>每次<code>freeblock</code>都指向一个内容为<code>NULL</code>的block，表明目前 pool 中没有其他之前被申请过但是当前已经被释放了的 block 存在，新申请空间的话，需要从 pool 尾部寻找之前没有用到过的新的空间。</p>
<p>这时候的管理更像是数组形式，<code>nextoffset</code>和 <code>maxnextoffset</code>在这种情况下会被用来查看 pool 尾部是否还有剩余的未使用过的空间。</p>
<p>然后就是更新<code>ref.count</code>，<code>nextoffset</code>，<code>freeblock</code>了。每次<code>freeblock</code>更新为<code>nextoffset</code>指向的地址，所以这里的图中，freeblock指向倒数第3个块，而pool+nextoffset在倒数第2个block</p>
<ul>
<li>
<p>这一部分的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pymalloc_pool_extend</span>(poolp pool, uint size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// freeblock为NULL时，扩展pool尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (UNLIKELY(pool<span style="color:#f92672">-&gt;</span>nextoffset <span style="color:#f92672">&lt;=</span> pool<span style="color:#f92672">-&gt;</span>maxnextoffset)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* There is room for another block. */</span>
</span></span><span style="display:flex;"><span>        pool<span style="color:#f92672">-&gt;</span>freeblock <span style="color:#f92672">=</span> (block<span style="color:#f92672">*</span>)pool <span style="color:#f92672">+</span> pool<span style="color:#f92672">-&gt;</span>nextoffset;
</span></span><span style="display:flex;"><span>        pool<span style="color:#f92672">-&gt;</span>nextoffset <span style="color:#f92672">+=</span> INDEX2SIZE(size);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(block <span style="color:#f92672">**</span>)(pool<span style="color:#f92672">-&gt;</span>freeblock) <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Pool is full, unlink from used pools. */</span>
</span></span><span style="display:flex;"><span>    poolp next;
</span></span><span style="display:flex;"><span>    next <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>nextpool;
</span></span><span style="display:flex;"><span>    pool <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>prevpool;
</span></span><span style="display:flex;"><span>    next<span style="color:#f92672">-&gt;</span>prevpool <span style="color:#f92672">=</span> pool;
</span></span><span style="display:flex;"><span>    pool<span style="color:#f92672">-&gt;</span>nextpool <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pymalloc_alloc</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx, size_t nbytes)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (UNLIKELY(nbytes <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (UNLIKELY(nbytes <span style="color:#f92672">&gt;</span> SMALL_REQUEST_THRESHOLD)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    uint size <span style="color:#f92672">=</span> (uint)(nbytes <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;&gt;</span> ALIGNMENT_SHIFT;
</span></span><span style="display:flex;"><span>    poolp pool <span style="color:#f92672">=</span> usedpools[size <span style="color:#f92672">+</span> size];
</span></span><span style="display:flex;"><span>    block <span style="color:#f92672">*</span>bp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (LIKELY(pool <span style="color:#f92672">!=</span> pool<span style="color:#f92672">-&gt;</span>nextpool)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * There is a used pool for this size class.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Pick up the head block of its free list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>pool<span style="color:#f92672">-&gt;</span>ref.count;
</span></span><span style="display:flex;"><span>        bp <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>freeblock;
</span></span><span style="display:flex;"><span>        assert(bp <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这里的freeblock赋值还是比较巧妙的，可以思考下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (UNLIKELY((pool<span style="color:#f92672">-&gt;</span>freeblock <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(block <span style="color:#f92672">**</span>)bp) <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Reached the end of the free list, try to extend it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            pymalloc_pool_extend(pool, size);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></li>
</ul>
<p>申请完毕后</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_4.png" alt=""  />
</p>
<p>再申请一个</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_5.png" alt=""  />
</p>
<p>此时<code>nextoffset</code>大于<code>maxnextoffset</code>了。</p>
<p>再申请</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_6.png" alt=""  />
</p>
<p><code>nextoffset</code> 的值比 <code>maxnextoffset</code> 的大, 表示尾部已经没有多余的新的未使用过的空间可以使用了, 并且目前情况下当前的pool是满的了, 所以<code>freeblock</code>变成了一个空指针</p>
<p>因为pool已经满了, 我们需要把pool从<code>usedpools</code>全局变量管理的双向链表中移除。本例中这个pool的block都是8字节，所以这个pool本来位于<code>usedpools[0]</code>和<code>usedpools[1]</code>维护的一条双链表中。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_7.png" alt=""  />
</p>
<p>在pool中释放block的核心代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    block <span style="color:#f92672">*</span>lastfree <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>freeblock;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(block <span style="color:#f92672">**</span>)p <span style="color:#f92672">=</span> lastfree;
</span></span><span style="display:flex;"><span>    pool<span style="color:#f92672">-&gt;</span>freeblock <span style="color:#f92672">=</span> (block <span style="color:#f92672">*</span>)p;
</span></span><span style="display:flex;"><span>    pool<span style="color:#f92672">-&gt;</span>ref.count<span style="color:#f92672">--</span>;
</span></span></code></pre></div><p>其实就是把要释放的内存，插入到<code>freeblock</code>指向的单链表中的<strong>头部</strong>。链表每个节点都是没有用到的block，正好用来指向下一个空闲block的地址。</p>
<h3 id="在满的-pool-中进行释放">在满的 pool 中进行释放<a hidden class="anchor" aria-hidden="true" href="#在满的-pool-中进行释放">#</a></h3>
<p>释放如图位置的block。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_8.png" alt=""  />
</p>
<p><strong>step1</strong>，把内存块里第一个<code>block</code>的值设置为和 <code>freeblock</code>相同的值，图中因为是满的，所以设置为了NULL</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_9.png" alt=""  />
</p>
<p><strong>step2</strong>, 让<code>freeblock</code>指向当前正在释放的block</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_10.png" alt=""  />
</p>
<p>减小<code>ref.count</code>的值</p>
<p><strong>step3</strong>，检查pool<strong>释放内存之前</strong>是否是满的(通过检查当前正在释放的block是否空指针即可确定)，如果是, 把pool重新链接到<code>usedpools</code>中并返回, 如果不是则跳转到 step4</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_11.png" alt=""  />
</p>
<p><strong>step4</strong></p>
<ul>
<li>
<p>检查当前arena中的所有的pools是否都为空的, 如果是的话, 释放整个arena</p>
</li>
<li>
<p>如果这是arena中唯一的有空余空间的pool，把arena加回到 <code>usable_arenas</code> 列表中</p>
</li>
<li>
<p>给<code>usable_arenas</code>进行排序, 确保更多空的<code>pool</code>的arena排在更后面</p>
</li>
<li>
<p>释放block的<code>pymalloc_free(void *ctx, void *p)</code>源码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// obmalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Free a memory block allocated by pymalloc_alloc().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   Return 1 if it was freed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   Return 0 if the block was not allocated by pymalloc_alloc(). */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pymalloc_free</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    assert(p <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef WITH_VALGRIND
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (UNLIKELY(running_on_valgrind <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    poolp pool <span style="color:#f92672">=</span> POOL_ADDR(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (UNLIKELY(<span style="color:#f92672">!</span>address_in_range(p, pool))) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* We allocated this address. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Link p to the start of the pool&#39;s freeblock list.  Since         // 用过但释放了的block，在此收入freeblock单链表进行管理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the pool had at least the p block outstanding, the pool
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * wasn&#39;t empty (so it&#39;s already in a usedpools[] list, or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * was full and is in no list -- it&#39;s not in the freeblocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * list in any case).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    assert(pool<span style="color:#f92672">-&gt;</span>ref.count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);            <span style="color:#75715e">/* else it was empty */</span>
</span></span><span style="display:flex;"><span>    block <span style="color:#f92672">*</span>lastfree <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>freeblock;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(block <span style="color:#f92672">**</span>)p <span style="color:#f92672">=</span> lastfree;
</span></span><span style="display:flex;"><span>    pool<span style="color:#f92672">-&gt;</span>freeblock <span style="color:#f92672">=</span> (block <span style="color:#f92672">*</span>)p;
</span></span><span style="display:flex;"><span>    pool<span style="color:#f92672">-&gt;</span>ref.count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (UNLIKELY(lastfree <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Pool was full, so doesn&#39;t currently live in any list:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * link it to the front of the appropriate usedpools[] list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * This mimics LRU pool usage for new allocations and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * targets optimal filling when several pools contain
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * blocks of the same size class.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        insert_to_usedpool(pool);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* freeblock wasn&#39;t NULL, so the pool wasn&#39;t full,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * and the pool is in a usedpools[] list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (LIKELY(pool<span style="color:#f92672">-&gt;</span>ref.count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* pool isn&#39;t empty:  leave it in usedpools */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Pool is now empty:  unlink from usedpools, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * link to the front of freepools.  This ensures that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * previously freed pools will be allocated later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * (being not referenced, they are perhaps paged out).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    insert_to_freepool(pool);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>POOL_ADDR(p)</code>的设计：
因为pool保证对齐到4KiB（定义了<code>USE_LARGE_POOL</code>时对齐到16KiB）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifdef USE_LARGE_POOLS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define POOL_BITS               14                  </span><span style="color:#75715e">/* 16 KiB */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define POOL_BITS               12                  </span><span style="color:#75715e">/* 4 KiB */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define POOL_SIZE               (1 &lt;&lt; POOL_BITS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) &amp; ~(uintptr_t)((a) - 1)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define POOL_ADDR(P) ((poolp)_Py_ALIGN_DOWN((P), POOL_SIZE))
</span></span></span></code></pre></div><p>简便起见，假如<code>POOL_SIZE</code>是<code>0b00001000</code>，一个block的地址是<code>0b00011010</code>，那么这里的计算方式就是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>  <span style="color:#ae81ff">0b00011010</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(<span style="color:#ae81ff">0b00001000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0b00011010</span> <span style="color:#f92672">&amp;</span>  <span style="color:#f92672">~</span><span style="color:#ae81ff">0b00000111</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0b00011010</span> <span style="color:#f92672">&amp;</span>   <span style="color:#ae81ff">0b11111000</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0b00011000</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="在有空余空间的-pool-中进行释放">在有空余空间的 pool 中进行释放<a hidden class="anchor" aria-hidden="true" href="#在有空余空间的-pool-中进行释放">#</a></h3>
<p>其实步骤和上面一样，比如释放最后一个内存块，位于<code>0x10ae3dff8</code></p>
<p><strong>Step1</strong> 设置当前释放的内存块的值</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_12.png" alt=""  />
</p>
<p><strong>Step2</strong></p>
<p>更新freeblock指针</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_13.png" alt=""  />
</p>
<p>减小<code>ref.count</code></p>
<p><strong>Step3</strong> 显然pool之前不是满的，直接跳到Step4</p>
<p><strong>Step4</strong> 返回</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_14.png" alt=""  />
</p>
<p>再来释放倒数第二个，也是同理</p>
<p>Step1</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_15.png" alt=""  />
</p>
<p><strong>Step2</strong></p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_16.png" alt=""  />
</p>
<p><strong>Step3</strong> pool之前不满，跳到step4</p>
<p><strong>Step4</strong>返回</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_17.png" alt=""  />
</p>
<h3 id="在释放过block的pool中申请新的空间">在释放过block的pool中申请新的空间<a hidden class="anchor" aria-hidden="true" href="#在释放过block的pool中申请新的空间">#</a></h3>
<p>和在未释放过block的pool中申请新的空间是一样的思路。从代码上来看</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// pymalloc_alloc in  obmalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>pool<span style="color:#f92672">-&gt;</span>ref.count;
</span></span><span style="display:flex;"><span>    bp <span style="color:#f92672">=</span> pool<span style="color:#f92672">-&gt;</span>freeblock;
</span></span><span style="display:flex;"><span>    assert(bp <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (UNLIKELY((pool<span style="color:#f92672">-&gt;</span>freeblock <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(block <span style="color:#f92672">**</span>)bp) <span style="color:#f92672">==</span> NULL)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Reached the end of the free list, try to extend it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pymalloc_pool_extend(pool, size);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>和之前的区别在于这次从<code>freeblock</code>获取到的不是NULL了，就不用进入<code>pymalloc_pool_extend()</code></p>
<h2 id="pool在arena和usedpools中的组织方式">pool在arena和usedpools中的组织方式<a hidden class="anchor" aria-hidden="true" href="#pool在arena和usedpools中的组织方式">#</a></h2>
<h3 id="内存请求的过程">内存请求的过程<a hidden class="anchor" aria-hidden="true" href="#内存请求的过程">#</a></h3>
<ul>
<li>一个arena中存储了许多大小相同的pool，不同arena的pool大小不一定相同。</li>
<li><code>arenas[]</code>保存了所有<code>arena_object</code></li>
<li><code>usedpools[]</code>是一个全局数组，其中的元素是个双向链表，<strong>两个元素为一组</strong>，将<strong>相同大小</strong>的pool串起来。一个size没有分配pool时，<code>usedpools[size+size]</code>里面的节点指向的pool的<code>prevpool</code>和<code>nextpool</code>都指向自己。</li>
</ul>
<p>先来看看<code>usedpools[]</code>，内存请求到达<code>pymalloc_alloc</code>时，小于等于<code>SMALL_REQUEST_THRESHOLD</code>的请求，就是在<code>usedpools</code>里来找合适大小的pool。寻找的方式是</p>
<ul>
<li>计算请求内存大小所属size class：<code>uint size = (uint)(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT</code></li>
<li>在<code>usedpools[size + size]</code>上寻找pool</li>
</ul>
<p>如果没有合适大小的pool，就会从<code>arenas</code>里请求新的pool，添加到对应位置的双向链表上，从这个新pool中申请block。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_18.png" alt=""  />
</p>
<ul>
<li>
<p>usedpools的初始定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// usedpools初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PT(x)   PTA(x), PTA(x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> poolp usedpools[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> ((NB_SMALL_SIZE_CLASSES <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    PT(<span style="color:#ae81ff">0</span>), PT(<span style="color:#ae81ff">1</span>), PT(<span style="color:#ae81ff">2</span>), PT(<span style="color:#ae81ff">3</span>), PT(<span style="color:#ae81ff">4</span>), PT(<span style="color:#ae81ff">5</span>), PT(<span style="color:#ae81ff">6</span>), PT(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">8</span>), PT(<span style="color:#ae81ff">9</span>), PT(<span style="color:#ae81ff">10</span>), PT(<span style="color:#ae81ff">11</span>), PT(<span style="color:#ae81ff">12</span>), PT(<span style="color:#ae81ff">13</span>), PT(<span style="color:#ae81ff">14</span>), PT(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">16</span>), PT(<span style="color:#ae81ff">17</span>), PT(<span style="color:#ae81ff">18</span>), PT(<span style="color:#ae81ff">19</span>), PT(<span style="color:#ae81ff">20</span>), PT(<span style="color:#ae81ff">21</span>), PT(<span style="color:#ae81ff">22</span>), PT(<span style="color:#ae81ff">23</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">24</span>), PT(<span style="color:#ae81ff">25</span>), PT(<span style="color:#ae81ff">26</span>), PT(<span style="color:#ae81ff">27</span>), PT(<span style="color:#ae81ff">28</span>), PT(<span style="color:#ae81ff">29</span>), PT(<span style="color:#ae81ff">30</span>), PT(<span style="color:#ae81ff">31</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">32</span>), PT(<span style="color:#ae81ff">33</span>), PT(<span style="color:#ae81ff">34</span>), PT(<span style="color:#ae81ff">35</span>), PT(<span style="color:#ae81ff">36</span>), PT(<span style="color:#ae81ff">37</span>), PT(<span style="color:#ae81ff">38</span>), PT(<span style="color:#ae81ff">39</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">40</span>), PT(<span style="color:#ae81ff">41</span>), PT(<span style="color:#ae81ff">42</span>), PT(<span style="color:#ae81ff">43</span>), PT(<span style="color:#ae81ff">44</span>), PT(<span style="color:#ae81ff">45</span>), PT(<span style="color:#ae81ff">46</span>), PT(<span style="color:#ae81ff">47</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 48
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">48</span>), PT(<span style="color:#ae81ff">49</span>), PT(<span style="color:#ae81ff">50</span>), PT(<span style="color:#ae81ff">51</span>), PT(<span style="color:#ae81ff">52</span>), PT(<span style="color:#ae81ff">53</span>), PT(<span style="color:#ae81ff">54</span>), PT(<span style="color:#ae81ff">55</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 56
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    , PT(<span style="color:#ae81ff">56</span>), PT(<span style="color:#ae81ff">57</span>), PT(<span style="color:#ae81ff">58</span>), PT(<span style="color:#ae81ff">59</span>), PT(<span style="color:#ae81ff">60</span>), PT(<span style="color:#ae81ff">61</span>), PT(<span style="color:#ae81ff">62</span>), PT(<span style="color:#ae81ff">63</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if NB_SMALL_SIZE_CLASSES &gt; 64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#error &#34;NB_SMALL_SIZE_CLASSES should be less than 64&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 64 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 56 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 48 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 40 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 32 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 24 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt; 16 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div></li>
</ul>
<p>上面这个代码有点巧妙，我们看下<code>usedpools@0x00007FFED35FF410</code>刚初始化后里面长啥样</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_19.png" alt=""  />
</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_20.png" alt=""  />
</p>
<p>回顾一下<code>pool_header</code>定义就知道是怎么回事了。</p>
<p>比如<code>0+0</code>位置上维护的双链表，<code>&amp;usedpools[0+0]</code>在<code>0x00007FFED35FF410</code>，而<code>usedpools[0+0]</code>为<code>0x00007FFED35FF400</code>，<code>(pool_header*)0x00007FFED35FF400-&gt;nextpool</code> 跨过两个指针大小的内存，刚好就指向<code>&amp;usedpools[0+0]</code>了，也就是<code>usedpools[size+size]-&gt;nextpool==&amp;usedpools[size+size]</code></p>
<p>总之初始化的值使得正好所有的<code>usedpools[size+size]</code>的pool的<code>prevpool</code>和<code>nextpool</code>字段都指向自己了。</p>
<p>现在假设我们一开始请求一个10字节的内存块。</p>
<p>初始时没有能用的arena和pool，于是在<code>new_arena()</code>中：第一次创建的是16个新的arena，分配了16个<code>arena_object</code>结构体的空间，保存到全局变量<code>arenas[]</code>。但并没有立即分配16个<code>ARENA_SIZE</code>的空间作为arena。然后初始化<code>unused_arena_objects</code>指向的<code>arena_object</code>，此时也就是<code>arenas[0]</code>。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_21.png" alt=""  />
</p>
<p>第一个可用的arena的第一个空闲pool被插入<code>used_pools</code>里。sentinel就是哨兵的意思，idx1指向的sentinel其实存的是<code>used_pools[0]</code>的地址（没理解的话查看上面内容）。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_22.png" alt=""  />
</p>
<p>然后按照前面讲到的<a href="https://www.wolai.com/87Y1jakYGgTFnNSbKPJ9G9">在未释放过block的pool中申请新的空间</a>获得请求所需要的内存块。</p>
<h3 id="arena中对pool的管理">arena中对pool的管理<a hidden class="anchor" aria-hidden="true" href="#arena中对pool的管理">#</a></h3>
<p>arena管理pool的方式和pool管理block的方式非常相似。也是数组+单链表。</p>
<p><code>arena_object</code>结构体：</p>
<ul>
<li>
<p>源码如下，注释说得比较清楚</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Record keeping for arenas. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> arena_object {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The address of the arena, as returned by malloc.  Note that 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * will never be returned by a successful malloc, and is used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * here to mark an arena_object that doesn&#39;t correspond to an
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * allocated arena.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    uintptr_t address;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Pool-aligned pointer to the next pool to be carved off. */</span>
</span></span><span style="display:flex;"><span>    block<span style="color:#f92672">*</span> pool_address;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The number of available pools in the arena:  free pools + never-
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * allocated pools.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    uint nfreepools;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The total number of pools in the arena, whether or not available. */</span>
</span></span><span style="display:flex;"><span>    uint ntotalpools;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Singly-linked list of available pools. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> pool_header<span style="color:#f92672">*</span> freepools;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Whenever this arena_object is not associated with an allocated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * arena, the nextarena member is used to link all unassociated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * arena_objects in the singly-linked `unused_arena_objects` list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The prevarena member is unused in this case.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * When this arena_object is associated with an allocated arena
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * with at least one available pool, both members are used in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * doubly-linked `usable_arenas` list, which is maintained in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * increasing order of `nfreepools` values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Else this arena_object is associated with an allocated arena
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * all of whose pools are in use.  `nextarena` and `prevarena`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * are both meaningless in this case.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> arena_object<span style="color:#f92672">*</span> nextarena;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> arena_object<span style="color:#f92672">*</span> prevarena;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ul>
<p>当然，我这可以再翻译一下和做点解释</p>
<p><code>address</code></p>
<p>用来保存分配给arena地址。</p>
<p><code>pool_address</code></p>
<p>pool的地址，指向下一个要取出的pool的地址</p>
<p>因为<code>malloc()</code>返回给arena的地址不一定对齐到<code>POOL_SIZE</code>，所以如果真的没有对齐，那么arena会舍弃前后加起来共<code>POOL_SIZE</code>大小的空间（图中<code>POOL_SIZE</code>为4K），保证最开始时，<code>pool_address</code>指向已经对齐好的pool，随时可以分配。</p>
<p>arena的对齐实现：</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_23.png" alt=""  />
</p>
<h4 id="在未释放过pool的arena中申请新的空间">在未释放过pool的arena中申请新的空间<a hidden class="anchor" aria-hidden="true" href="#在未释放过pool的arena中申请新的空间">#</a></h4>
<p>按顺序，前面的所有pool都是used，<code>pool_address</code>负责指向空闲内存</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_24.png" alt=""  />
</p>
<p>申请一个新的pool，从<code>pool_address</code>上取</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_25.png" alt=""  />
</p>
<p><code>nfreepools</code>减小，<code>pool_address</code>更新为下一个空余的pool</p>
<p>再申请一个，满了。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_26.png" alt=""  />
</p>
<h4 id="在arena中释放空间">在arena中释放空间<a hidden class="anchor" aria-hidden="true" href="#在arena中释放空间">#</a></h4>
<p>pool变为empty时，pool从<code>usedpools</code>中移除，插入到与之对应的arena中，<code>freepools</code>所管理的单链表中。</p>
<p>比如我们释放pool3</p>
<p><code>pool3-&gt;nextpool</code>设置为<code>arena-&gt;freepools</code>相同值。因为是满了之后第一个释放的，所以这个时候是0</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_27.png" alt=""  />
</p>
<p>freepools更新为pool3的地址，nfreepools增加</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_28.png" alt=""  />
</p>
<p>比如再释放一个pool63</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_29.png" alt=""  />
</p>
<h4 id="在释放过pool的arena中申请新的空间">在释放过pool的arena中申请新的空间<a hidden class="anchor" aria-hidden="true" href="#在释放过pool的arena中申请新的空间">#</a></h4>
<p>在arena中申请新的空间，先判断<code>freepools</code>是不是<code>NULL</code>。这里的情况下，<code>nfreepools</code>大于0，<code>freepools</code>不为空，从这个单链表中取pool。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_30.png" alt=""  />
</p>
<p>更新<code>freepools</code>指针，和<code>nfreepools</code></p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_31.png" alt=""  />
</p>
<h2 id="arena的管理">arena的管理<a hidden class="anchor" aria-hidden="true" href="#arena的管理">#</a></h2>
<p>arena由<code>arena_object</code>结构体数组<code>arenas[]</code>和链表<code>unused_arena_objects</code>和<code>usable_arenas</code>进行管理。</p>
<p><strong>单链表</strong>**<code>unused_arena_objects</code>**</p>
<p>维护<code>arenas</code>中所有pool都没被使用或都被释放了的<code>arena_object</code>，凡是放入这个链表的<code>arena_object</code>，其arena占用的pool都会被释放，但<code>arena_object</code>结构体本身不会被释放。</p>
<p>在 Python 2.5 之前, arena申请过的空间是从来不会被释放的, 这个策略是在 Python 2.5 之后引入的。</p>
<p><strong>双向链表</strong>**<code>usable_arenas</code>**
维护有空闲pool的arena的<code>arena_object</code></p>
<p>第一次内存请求前没有分配<code>arena_object</code>，<code>usable_arenas == NULL</code>，第一次分配时，分配16个<code>arena_object</code>存入<code>arenas[]</code>，之后每次扩容arenas，总共分配的<code>arena_object</code>数量翻倍。</p>
<p>由于是第一次分配，所以先构建<code>unused_arena_objects</code>单链表，留在这个链表中的<code>arena_object</code>一定是没分配实际内存的，也就是<code>address</code>字段是0</p>
<p>（白色为不关联实际内存，绿色表示有可用pool，红色表示所有pool已满）</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_32.png" alt=""  />
</p>
<p><code>new_arena()</code>内从<code>unused_arena_objects</code>处获取<code>arena_object</code>并为之真正分配<code>ARENA_SIZE</code>的内存，做好初始化：对齐arena中的pool到POOL_SIZE，设置一些字段。</p>
<p><code>usable_arenas</code>是个双向链表（下图没体现出来），维护包含空闲pool的arena，管理的<code>arena_object</code>按其<code>nfreepools</code>升序排列，获取pool时，优先从重度使用的arena中分配，这样可以让比较空的arena有更多释放内存的可能性。</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_33.png" alt=""  />
</p>
<p>16个arena都用完了的时候，<code>arena_objects</code>数量翻倍，然后做前面同样的初始化。</p>
<p>扩容用的realloc，不用管指针了？是的。因为既然前面的<code>arena_objects</code>对应的arena都满了，<code>usable_arenas</code>和<code>unused_arena_objects</code>就都为<code>NULL</code>了，自然也没有<code>nextarena</code>，<code>prevarena</code>指针指向原来的内存，realloc后，构建新的<code>unused_arena_objects</code>单链表</p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_34.png" alt=""  />
</p>
<p>返回新的arena给<code>usable_arenas</code></p>
<p><img loading="lazy" src="/cpython_memory_model/image/image_35.png" alt=""  />
</p>
<ul>
<li>
<p><code>new_arena()</code>源码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// obmalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Allocate a new arena.  If we run out of memory, return NULL.  Else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * allocate a new arena, and return the address of an arena_object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * describing the new arena.  It&#39;s expected that the caller will set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * `usable_arenas` to the return value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> arena_object<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">new_arena</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> arena_object<span style="color:#f92672">*</span> arenaobj;
</span></span><span style="display:flex;"><span>    uint excess;        <span style="color:#75715e">/* number of bytes above pool alignment */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>address;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> debug_stats <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (debug_stats <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>opt <span style="color:#f92672">=</span> Py_GETENV(<span style="color:#e6db74">&#34;PYTHONMALLOCSTATS&#34;</span>);
</span></span><span style="display:flex;"><span>        debug_stats <span style="color:#f92672">=</span> (opt <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>opt <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (debug_stats)
</span></span><span style="display:flex;"><span>        _PyObject_DebugMallocStats(stderr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (unused_arena_objects <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        uint i;
</span></span><span style="display:flex;"><span>        uint numarenas;
</span></span><span style="display:flex;"><span>        size_t nbytes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Double the number of arena objects on each allocation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Note that it&#39;s possible for `numarenas` to overflow.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        numarenas <span style="color:#f92672">=</span> maxarenas <span style="color:#f92672">?</span> maxarenas <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> INITIAL_ARENA_OBJECTS;     <span style="color:#75715e">// 将最大arenas数量翻倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (numarenas <span style="color:#f92672">&lt;=</span> maxarenas)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;                <span style="color:#75715e">/* overflow */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if SIZEOF_SIZE_T &lt;= SIZEOF_INT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (numarenas <span style="color:#f92672">&gt;</span> SIZE_MAX <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>arenas))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;                <span style="color:#75715e">/* overflow */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        nbytes <span style="color:#f92672">=</span> numarenas <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>arenas);
</span></span><span style="display:flex;"><span>        arenaobj <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> arena_object <span style="color:#f92672">*</span>)PyMem_RawRealloc(arenas, nbytes); <span style="color:#75715e">// realloc内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (arenaobj <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        arenas <span style="color:#f92672">=</span> arenaobj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* We might need to fix pointers that were copied.  However,        // Realloc后的指针无需处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * new_arena only gets called when all the pages in the             // 因为前面的arena满了，才需要realloc，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * previous arenas are full.  Thus, there are *no* pointers         // 既然满了，就没有指针(unused_arena_objects 和 usable_arenas链表中的指针)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * into the old array. Thus, we don&#39;t have to worry about           // 指向原来的arenas数组里。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * invalid pointers.  Just to be sure, some asserts:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        assert(usable_arenas <span style="color:#f92672">==</span> NULL);
</span></span><span style="display:flex;"><span>        assert(unused_arena_objects <span style="color:#f92672">==</span> NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Put the new arenas on the unused_arena_objects list. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> maxarenas; i <span style="color:#f92672">&lt;</span> numarenas; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            arenas[i].address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;              <span style="color:#75715e">/* mark as unassociated */</span>
</span></span><span style="display:flex;"><span>            arenas[i].nextarena <span style="color:#f92672">=</span> i <span style="color:#f92672">&lt;</span> numarenas <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                                   <span style="color:#f92672">&amp;</span>arenas[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">:</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Update globals. */</span>
</span></span><span style="display:flex;"><span>        unused_arena_objects <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>arenas[maxarenas];                          <span style="color:#75715e">// unused_arena_objects指向arenas新扩容出来的部分头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        maxarenas <span style="color:#f92672">=</span> numarenas;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Take the next available arena object off the head of the list. */</span>
</span></span><span style="display:flex;"><span>    assert(unused_arena_objects <span style="color:#f92672">!=</span> NULL);
</span></span><span style="display:flex;"><span>    arenaobj <span style="color:#f92672">=</span> unused_arena_objects;
</span></span><span style="display:flex;"><span>    unused_arena_objects <span style="color:#f92672">=</span> arenaobj<span style="color:#f92672">-&gt;</span>nextarena;
</span></span><span style="display:flex;"><span>    assert(arenaobj<span style="color:#f92672">-&gt;</span>address <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    address <span style="color:#f92672">=</span> _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if WITH_PYMALLOC_RADIX_TREE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (address <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>arena_map_mark_used((uintptr_t)address, <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* marking arena in radix tree failed, abort */</span>
</span></span><span style="display:flex;"><span>            _PyObject_Arena.free(_PyObject_Arena.ctx, address, ARENA_SIZE);
</span></span><span style="display:flex;"><span>            address <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (address <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* The allocation failed: return NULL after putting the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * arenaobj back.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        arenaobj<span style="color:#f92672">-&gt;</span>nextarena <span style="color:#f92672">=</span> unused_arena_objects;
</span></span><span style="display:flex;"><span>        unused_arena_objects <span style="color:#f92672">=</span> arenaobj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    arenaobj<span style="color:#f92672">-&gt;</span>address <span style="color:#f92672">=</span> (uintptr_t)address;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>narenas_currently_allocated;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>ntimes_arena_allocated;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (narenas_currently_allocated <span style="color:#f92672">&gt;</span> narenas_highwater)
</span></span><span style="display:flex;"><span>        narenas_highwater <span style="color:#f92672">=</span> narenas_currently_allocated;
</span></span><span style="display:flex;"><span>    arenaobj<span style="color:#f92672">-&gt;</span>freepools <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* pool_address &lt;- first pool-aligned address in the arena
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       nfreepools &lt;- number of whole pools that fit after alignment */</span>
</span></span><span style="display:flex;"><span>    arenaobj<span style="color:#f92672">-&gt;</span>pool_address <span style="color:#f92672">=</span> (block<span style="color:#f92672">*</span>)arenaobj<span style="color:#f92672">-&gt;</span>address;
</span></span><span style="display:flex;"><span>    arenaobj<span style="color:#f92672">-&gt;</span>nfreepools <span style="color:#f92672">=</span> MAX_POOLS_IN_ARENA;
</span></span><span style="display:flex;"><span>    excess <span style="color:#f92672">=</span> (uint)(arenaobj<span style="color:#f92672">-&gt;</span>address <span style="color:#f92672">&amp;</span> POOL_SIZE_MASK); <span style="color:#75715e">// 当前arena地址没对齐到pool大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (excess <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">--</span>arenaobj<span style="color:#f92672">-&gt;</span>nfreepools;                          <span style="color:#75715e">// 为了对齐pool，可用pool会减少一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        arenaobj<span style="color:#f92672">-&gt;</span>pool_address <span style="color:#f92672">+=</span> POOL_SIZE <span style="color:#f92672">-</span> excess;    <span style="color:#75715e">// 进行对齐操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    arenaobj<span style="color:#f92672">-&gt;</span>ntotalpools <span style="color:#f92672">=</span> arenaobj<span style="color:#f92672">-&gt;</span>nfreepools;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> arenaobj;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h1 id="一些api">一些API<a hidden class="anchor" aria-hidden="true" href="#一些api">#</a></h1>
<h2 id="obmalloc中的调用链">obmalloc中的调用链<a hidden class="anchor" aria-hidden="true" href="#obmalloc中的调用链">#</a></h2>
<p><code>_PyObject_Malloc</code>和<code>_PyObject_Calloc</code>调用<code>pymalloc_alloc</code>，申请的内存大于<code>SMALL_REQUEST_THRESHOLD</code>的内存时，<code>pymalloc_alloc</code>返回NULL，于是前者又分别会调用<code>PyMem_RawMalloc</code>和<code>PyMem_RawCalloc</code></p>
<p>参考源码<code>_PyObject_Malloc</code>和<code>_PyObject_Calloc</code>的实现</p>
<p>small request的调用链</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>PyObject_Malloc(size_t size)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> _PyObject.malloc  <span style="color:#f92672">==</span> (PYOBJ_ALLOC <span style="color:#f92672">==</span> PYMALLOC_ALLOC).malloc <span style="color:#f92672">==</span> _PyObject_Malloc
</span></span><span style="display:flex;"><span>    _PyObject_Malloc(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx, size_t nbytes)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-&gt;</span> pymalloc_alloc(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx, size_t nbytes) get memory from pool
</span></span></code></pre></div><p>bigger request的调用链</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>PyObject_Malloc(size_t size)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> _PyObject.malloc  <span style="color:#f92672">==</span> (PYOBJ_ALLOC <span style="color:#f92672">==</span> PYMALLOC_ALLOC).malloc <span style="color:#f92672">==</span> _PyObject_Malloc
</span></span><span style="display:flex;"><span>    _PyObject_Malloc(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx, size_t nbytes)
</span></span><span style="display:flex;"><span>        get NULL from pymalloc_alloc
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-&gt;</span> PyMem_RawMalloc(size_t size)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">-&gt;</span> malloc(size_t size) of CRT
</span></span></code></pre></div><p><code>PyMem_</code>系列</p>
<p><code>obmalloc.c</code>中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef WITH_PYMALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PYRAW_ALLOC MALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef WITH_PYMALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYOBJ_ALLOC PYMALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#  define PYOBJ_ALLOC MALLOC_ALLOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PYMEM_ALLOC PYOBJ_ALLOC
</span></span></span></code></pre></div><p>默认是定义了<code>WITH_PYMALLOC</code>的，也就是说默认选用<code>_PyObject_*</code>函数族而不是<code>_PyMem_Raw*</code></p>
<p>WITH_PYMALLOC</p>
<p>PYMEM_ALLOC→PYOBJ_ALLOC→PYMALLOC_ALLOC→<code>_PyObject_*</code>函数族</p>
<p>没有WITH_PYMALLOC</p>
<p>PYMEM_ALLOC→PYOBJ_ALLOC→MALLOC_ALLOC→<code>_PyMem_Raw*</code>函数族</p>
<h1 id="todo">TODO<a hidden class="anchor" aria-hidden="true" href="#todo">#</a></h1>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://github.com/python/cpython/commit/1c263e39c4ed28225a7dc8ca1f24953225ac48ca#diff-399a22135f328b4e42b0722ef216587945eedf2d8c103a584a3dca5b30650329">bpo-37029: keep usable_arenas in sorted order without searching (#13… · python/cpython@1c263e3 (github.com)</a></li>
</ul>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://xxr0ss.github.io/">XX の Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
